# Epic 4: Security, SRE & Observability
## Story 4.11: Security Vulnerability Scanning

**Dependencies:** 
- Epic 1, Story 1.1 (Initial Project Setup) - COMPLETED ✅
- CI/CD pipeline setup

**Can be implemented:** NOW ✅

*As a security engineer, I want automated vulnerability scanning, so that we identify and fix security issues quickly.*

### Acceptance Criteria
1. Dependency scanning in CI/CD pipeline
2. Container image scanning for deployments
3. Weekly security reports generated
4. Critical vulnerabilities block deployments
5. Security advisories monitored automatically
6. Remediation SLAs defined and tracked

### Development Tasks
- [ ] Configure dependency scanning (Snyk/Dependabot)
- [ ] Set up container image scanning
- [ ] Implement SAST (Static Application Security Testing)
- [ ] Configure secret scanning
- [ ] Set up security advisory monitoring
- [ ] Create vulnerability tracking system
- [ ] Build security dashboard
- [ ] Implement automated patching
- [ ] Create remediation workflows
- [ ] Set up security metrics collection

### Technical Details

#### Dependency Scanning Configuration
```yaml
# .github/workflows/security-scan.yml
name: Security Scanning

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 9 * * 1' # Weekly on Monday

jobs:
  dependency-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --fail-on=upgradable
          
      - name: Upload Snyk results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: snyk.sarif
          
  npm-audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install dependencies
        run: pnpm install
        
      - name: Run npm audit
        run: |
          pnpm audit --json > audit-report.json
          
          # Check for critical/high vulnerabilities
          CRITICAL=$(jq '.metadata.vulnerabilities.critical' audit-report.json)
          HIGH=$(jq '.metadata.vulnerabilities.high' audit-report.json)
          
          if [ "$CRITICAL" -gt 0 ] || [ "$HIGH" -gt 0 ]; then
            echo "::error::Found $CRITICAL critical and $HIGH high vulnerabilities"
            exit 1
          fi
```

#### Container Image Scanning
```yaml
# dockerfile-scan.yml
container-scan:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: docker build -t app:${{ github.sha }} .
      
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: app:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH'
        exit-code: '1'
        
    - name: Run Grype scanner
      uses: anchore/scan-action@v3
      with:
        image: app:${{ github.sha }}
        fail-build: true
        severity-cutoff: high
```

#### SAST Implementation
```yaml
# static-analysis.yml
sast-scan:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v3
    
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: javascript, typescript
        
    - name: Run CodeQL Analysis
      uses: github/codeql-action/analyze@v2
      
    - name: Run Semgrep
      uses: returntocorp/semgrep-action@v1
      with:
        config: >
          p/security-audit
          p/typescript
          p/react
          p/nextjs
        generateSarif: true
        
    - name: ESLint Security Plugin
      run: |
        pnpm eslint . --ext .ts,.tsx \
          --plugin security \
          --rule 'security/detect-object-injection: error' \
          --rule 'security/detect-non-literal-regexp: error'
```

#### Secret Scanning
```typescript
// scripts/secret-scan.ts
import { simpleGit } from 'simple-git';
import { detectSecrets } from 'detect-secrets';

export async function scanForSecrets() {
  const git = simpleGit();
  const files = await git.diff(['--name-only', 'HEAD~1']);
  
  const secretPatterns = [
    {
      name: 'AWS Access Key',
      pattern: /AKIA[0-9A-Z]{16}/,
    },
    {
      name: 'Stripe Secret Key',
      pattern: /sk_[a-zA-Z]{4}_[a-zA-Z0-9]{24}/,
    },
    {
      name: 'Generic API Key',
      pattern: /['"]?api[_-]?key['"]?\s*[:=]\s*['"][a-zA-Z0-9]{32,}['"]/i,
    },
    {
      name: 'Private Key',
      pattern: /-----BEGIN (RSA |EC )?PRIVATE KEY-----/,
    },
  ];
  
  const findings = [];
  
  for (const file of files) {
    const content = await fs.readFile(file, 'utf-8');
    
    for (const { name, pattern } of secretPatterns) {
      if (pattern.test(content)) {
        findings.push({
          file,
          type: name,
          severity: 'critical',
        });
      }
    }
  }
  
  return findings;
}
```

#### Vulnerability Tracking System
```typescript
// services/vulnerabilityTracker.ts
export interface Vulnerability {
  id: string;
  source: 'snyk' | 'npm' | 'codeql' | 'trivy';
  severity: 'critical' | 'high' | 'medium' | 'low';
  cve?: string;
  package: string;
  version: string;
  fixedVersion?: string;
  description: string;
  detectedAt: Date;
  remediatedAt?: Date;
  slaDeadline: Date;
  assignee?: string;
  status: 'open' | 'in_progress' | 'remediated' | 'accepted';
}

export class VulnerabilityTracker {
  private readonly SLA_HOURS = {
    critical: 24,    // 24 hours
    high: 72,        // 3 days
    medium: 168,     // 7 days
    low: 720,        // 30 days
  };
  
  async trackVulnerability(vuln: Vulnerability) {
    // Calculate SLA deadline
    const slaHours = this.SLA_HOURS[vuln.severity];
    const deadline = new Date(vuln.detectedAt);
    deadline.setHours(deadline.getHours() + slaHours);
    
    vuln.slaDeadline = deadline;
    
    // Store vulnerability
    await db.vulnerability.create({ data: vuln });
    
    // Notify security team
    if (vuln.severity === 'critical' || vuln.severity === 'high') {
      await this.notifySecurityTeam(vuln);
    }
    
    // Create remediation task
    await this.createRemediationTask(vuln);
  }
  
  async checkSLACompliance() {
    const openVulns = await db.vulnerability.findMany({
      where: {
        status: { in: ['open', 'in_progress'] },
        slaDeadline: { lt: new Date() },
      },
    });
    
    for (const vuln of openVulns) {
      await this.escalateVulnerability(vuln);
    }
  }
}
```

#### Automated Patching
```typescript
// scripts/auto-patch.ts
export async function autoPatachDependencies() {
  // Run npm update for patch versions
  await exec('pnpm update --depth 0');
  
  // Check for vulnerabilities
  const auditResult = await exec('pnpm audit --json');
  const vulnerabilities = JSON.parse(auditResult.stdout);
  
  // Attempt to fix automatically
  if (vulnerabilities.metadata.vulnerabilities.total > 0) {
    await exec('pnpm audit fix');
    
    // Run tests to ensure nothing broke
    const testResult = await exec('pnpm test').catch(e => e);
    
    if (testResult.code === 0) {
      // Create PR with fixes
      await createPullRequest({
        title: 'chore: automated security patches',
        body: generatePatchReport(vulnerabilities),
        branch: 'auto-patch-' + Date.now(),
      });
    } else {
      // Manual intervention required
      await notifySecurityTeam({
        message: 'Automated patching failed tests',
        vulnerabilities,
        testOutput: testResult.stderr,
      });
    }
  }
}
```

#### Security Dashboard
```typescript
// pages/admin/security-dashboard.tsx
export function SecurityDashboard() {
  const { data: metrics } = api.security.getMetrics.useQuery();
  
  return (
    <div>
      <h1>Security Dashboard</h1>
      
      <div className="metrics-grid">
        <MetricCard
          title="Open Vulnerabilities"
          value={metrics?.openVulnerabilities}
          trend={metrics?.vulnerabilityTrend}
          severity="high"
        />
        
        <MetricCard
          title="Mean Time to Remediate"
          value={metrics?.mttr}
          unit="hours"
        />
        
        <MetricCard
          title="Dependencies Scanned"
          value={metrics?.dependenciesScanned}
          lastScan={metrics?.lastScanTime}
        />
        
        <MetricCard
          title="SLA Compliance"
          value={metrics?.slaCompliance}
          unit="%"
          target={95}
        />
      </div>
      
      <VulnerabilityList
        vulnerabilities={metrics?.vulnerabilities}
        onRemediate={handleRemediate}
      />
      
      <SecurityTimeline
        events={metrics?.securityEvents}
      />
    </div>
  );
}
```

### Testing Checklist
- [ ] Verify dependency scanning catches known vulnerabilities
- [ ] Test container scanning blocks vulnerable images
- [ ] Verify SAST identifies security issues
- [ ] Test secret scanning prevents credential commits
- [ ] Verify SLA tracking and escalation
- [ ] Test automated patching workflow
- [ ] Verify security metrics are accurate
- [ ] Test integration with CI/CD pipeline

### Definition of Done
- [ ] Dependency scanning configured and running
- [ ] Container scanning integrated in pipeline
- [ ] SAST tools configured and tuned
- [ ] Secret scanning preventing leaks
- [ ] Vulnerability tracking system operational
- [ ] Automated patching configured
- [ ] Security dashboard deployed
- [ ] Team trained on remediation process
- [ ] Documentation completed
- [ ] Deployed to production
